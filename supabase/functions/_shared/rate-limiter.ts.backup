// ============= Rate Limiting Middleware for Edge Functions =============
// Provides tier-based rate limiting with sliding window implementation

import { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2';

// ============= Types =============

export interface RateLimitConfig {
  maxRequests: number;
  windowSeconds: number;
}

export interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  resetAt: Date;
  retryAfterSeconds?: number;
}

export interface UserTier {
  tier: 'free' | 'pro' | 'enterprise';
  customLimits?: Partial<Record<string, RateLimitConfig>>;
}

// ============= Rate Limit Configurations =============

// Default limits by tier (requests per minute)
export const TIER_LIMITS: Record<string, Record<string, RateLimitConfig>> = {
  free: {
    chat: { maxRequests: 20, windowSeconds: 60 },
    search: { maxRequests: 30, windowSeconds: 60 },
    document_upload: { maxRequests: 10, windowSeconds: 60 },
    document_process: { maxRequests: 5, windowSeconds: 60 },
    api_ingest: { maxRequests: 100, windowSeconds: 60 },
    generate: { maxRequests: 10, windowSeconds: 60 },
    default: { maxRequests: 60, windowSeconds: 60 },
  },
  pro: {
    chat: { maxRequests: 60, windowSeconds: 60 },
    search: { maxRequests: 100, windowSeconds: 60 },
    document_upload: { maxRequests: 30, windowSeconds: 60 },
    document_process: { maxRequests: 20, windowSeconds: 60 },
    api_ingest: { maxRequests: 500, windowSeconds: 60 },
    generate: { maxRequests: 30, windowSeconds: 60 },
    default: { maxRequests: 200, windowSeconds: 60 },
  },
  enterprise: {
    chat: { maxRequests: 200, windowSeconds: 60 },
    search: { maxRequests: 500, windowSeconds: 60 },
    document_upload: { maxRequests: 100, windowSeconds: 60 },
    document_process: { maxRequests: 50, windowSeconds: 60 },
    api_ingest: { maxRequests: 2000, windowSeconds: 60 },
    generate: { maxRequests: 100, windowSeconds: 60 },
    default: { maxRequests: 1000, windowSeconds: 60 },
  },
};

// In-memory sliding window counters (per-instance)
// Format: userId:endpoint -> { count, windowStart }
const rateLimitCounters = new Map<string, { count: number; windowStart: number }>();

// Cleanup old entries every 5 minutes
const CLEANUP_INTERVAL_MS = 5 * 60 * 1000;
let lastCleanup = Date.now();

function cleanupOldEntries(): void {
  const now = Date.now();
  if (now - lastCleanup < CLEANUP_INTERVAL_MS) return;
  
  lastCleanup = now;
  const cutoff = now - 120000; // Remove entries older than 2 minutes
  
  for (const [key, value] of rateLimitCounters.entries()) {
    if (value.windowStart < cutoff) {
      rateLimitCounters.delete(key);
    }
  }
}

// ============= Rate Limiter Class =============

export class RateLimiter {
  private supabase: SupabaseClient;
  
  constructor(supabase: SupabaseClient) {
    this.supabase = supabase;
  }
  
  /**
   * Check if a request should be allowed based on rate limits
   */
  async checkLimit(
    userId: string,
    endpoint: string,
    tier: 'free' | 'pro' | 'enterprise' = 'free'
  ): Promise<RateLimitResult> {
    cleanupOldEntries();
    
    const config = TIER_LIMITS[tier]?.[endpoint] || TIER_LIMITS[tier]?.default || TIER_LIMITS.free.default;
    const key = `${userId}:${endpoint}`;
    const now = Date.now();
    const windowStart = now - (config.windowSeconds * 1000);
    
    // Get or create counter
    let counter = rateLimitCounters.get(key);
    
    if (!counter || counter.windowStart < windowStart) {
      // Start new window
      counter = { count: 1, windowStart: now };
      rateLimitCounters.set(key, counter);
      
      return {
        allowed: true,
        remaining: config.maxRequests - 1,
        resetAt: new Date(now + config.windowSeconds * 1000),
      };
    }
    
    // Check if within limit
    if (counter.count < config.maxRequests) {
      counter.count++;
      
      return {
        allowed: true,
        remaining: config.maxRequests - counter.count,
        resetAt: new Date(counter.windowStart + config.windowSeconds * 1000),
      };
    }
    
    // Rate limited
    const resetAt = new Date(counter.windowStart + config.windowSeconds * 1000);
    const retryAfterSeconds = Math.ceil((resetAt.getTime() - now) / 1000);
    
    // Log rate limit hit
    this.logRateLimitHit(userId, endpoint, tier);
    
    return {
      allowed: false,
      remaining: 0,
      resetAt,
      retryAfterSeconds,
    };
  }
  
  /**
   * Get user's subscription tier from database
   */
  async getUserTier(userId: string): Promise<'free' | 'pro' | 'enterprise'> {
    try {
      const { data } = await this.supabase
        .from('user_subscriptions')
        .select('tier')
        .eq('user_id', userId)
        .eq('status', 'active')
        .single();
      
      if (data?.tier && ['free', 'pro', 'enterprise'].includes(data.tier)) {
        return data.tier as 'free' | 'pro' | 'enterprise';
      }
      
      return 'free';
    } catch {
      return 'free';
    }
  }
  
  /**
   * Log rate limit hit for monitoring
   */
  private async logRateLimitHit(userId: string, endpoint: string, tier: string): Promise<void> {
    try {
      await this.supabase.from('audit_logs').insert({
        user_id: userId,
        user_name: 'Rate Limiter',
        action: 'rate_limit_exceeded',
        resource_type: 'api',
        resource_id: endpoint,
        resource_name: `Rate limit hit: ${endpoint}`,
        severity_level: 'warn',
        details: { endpoint, tier, timestamp: new Date().toISOString() },
      });
    } catch (err) {
      console.warn('[rate-limiter] Failed to log rate limit hit:', err);
    }
  }
}

// ============= Factory Function =============

export function createRateLimiter(supabase: SupabaseClient): RateLimiter {
  return new RateLimiter(supabase);
}

// ============= Middleware Helper =============

/**
 * Rate limit middleware for Edge Functions
 * Returns a Response if rate limited, null if allowed
 */
export async function rateLimitMiddleware(
  supabase: SupabaseClient,
  userId: string,
  endpoint: string,
  corsHeaders: Record<string, string>
): Promise<Response | null> {
  const limiter = createRateLimiter(supabase);
  const tier = await limiter.getUserTier(userId);
  const result = await limiter.checkLimit(userId, endpoint, tier);
  
  if (!result.allowed) {
    return new Response(
      JSON.stringify({
        error: 'Rate limit exceeded',
        message: `Too many requests. Please retry after ${result.retryAfterSeconds} seconds.`,
        retryAfter: result.retryAfterSeconds,
        resetAt: result.resetAt.toISOString(),
      }),
      {
        status: 429,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json',
          'Retry-After': String(result.retryAfterSeconds),
          'X-RateLimit-Limit': String(TIER_LIMITS[tier]?.[endpoint]?.maxRequests || TIER_LIMITS[tier]?.default.maxRequests),
          'X-RateLimit-Remaining': '0',
          'X-RateLimit-Reset': String(Math.floor(result.resetAt.getTime() / 1000)),
        },
      }
    );
  }
  
  return null;
}

// ============= Rate Limit Headers Helper =============

/**
 * Add rate limit headers to a response
 */
export function addRateLimitHeaders(
  headers: Record<string, string>,
  result: RateLimitResult,
  tier: 'free' | 'pro' | 'enterprise',
  endpoint: string
): Record<string, string> {
  const config = TIER_LIMITS[tier]?.[endpoint] || TIER_LIMITS[tier]?.default || TIER_LIMITS.free.default;
  
  return {
    ...headers,
    'X-RateLimit-Limit': String(config.maxRequests),
    'X-RateLimit-Remaining': String(result.remaining),
    'X-RateLimit-Reset': String(Math.floor(result.resetAt.getTime() / 1000)),
  };
}
